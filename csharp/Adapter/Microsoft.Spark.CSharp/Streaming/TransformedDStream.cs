// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading.Tasks;

using Microsoft.Spark.CSharp.Core;
using Microsoft.Spark.CSharp.Proxy;
using Microsoft.Spark.CSharp.Interop;
using SerializationHelpers.Data;
using System.Linq.Expressions;
using SerializationHelpers.Extensions;

namespace Microsoft.Spark.CSharp.Streaming
{
    /// <summary>
    /// TransformedDStream is an DStream generated by an C# function
    /// transforming each RDD of an DStream to another RDDs.
    /// 
    /// Multiple continuous transformations of DStream can be combined into
    /// one transformation.
    /// </summary>
    /// <typeparam name="U"></typeparam>
    [Serializable]
    internal class TransformedDStream<U> : DStream<U>
    {
        internal LinqExpressionData expressionData;
        //internal Func<double, RDD<dynamic>, RDD<dynamic>> func;
        internal LinqExpressionData prevExpressionData;
        //private Func<double, RDD<dynamic>, RDD<dynamic>> prevFunc;

        internal void Init<T>(DStream<T> prev, Expression<Func<double, RDD<dynamic>, RDD<dynamic>>> f)
        {
            streamingContext = prev.streamingContext;
            serializedMode = SerializedMode.Byte;
            isCached = false;
            isCheckpointed = false;
            dstreamProxy = null;

            if (prev is TransformedDStream<T> && !prev.isCached && !prev.isCheckpointed)
            {
                prevExpressionData = (prev as TransformedDStream<T>).expressionData;
                Expression<Func<double, RDD<dynamic>, RDD<dynamic>>> newFunc = (newFuncX, newFuncY) => new NewFuncWrapper(expressionData.ToExpression<Func<double, RDD<dynamic>, RDD<dynamic>>>(), prevExpressionData.ToExpression<Func<double, RDD<dynamic>, RDD<dynamic>>>()).Execute(newFuncX, newFuncY);
                expressionData = newFunc.ToExpressionData();
                prevDStreamProxy = prev.prevDStreamProxy;
                prevSerializedMode = prev.prevSerializedMode;
            }
            else
            {
                prevDStreamProxy = prev.dstreamProxy;
                prevSerializedMode = prev.serializedMode;
                expressionData = f.ToExpressionData();
            }
        }

        [Serializable]
        private class NewFuncWrapper
        {
            internal LinqExpressionData expressionData;
            //private readonly Func<double, RDD<dynamic>, RDD<dynamic>> func;
            internal LinqExpressionData prevExpressionData;
            //private readonly Func<double, RDD<dynamic>, RDD<dynamic>> prevFunc;
            internal NewFuncWrapper(Expression<Func<double, RDD<dynamic>, RDD<dynamic>>> func, Expression<Func<double, RDD<dynamic>, RDD<dynamic>>> prevFunc)
            {
                this.expressionData = func.ToExpressionData();
                this.prevExpressionData = prevFunc.ToExpressionData();
            }

            internal RDD<dynamic> Execute(double t, RDD<dynamic> rdd)
            {
                var func = expressionData.ToFunc<Func<double, RDD<dynamic>, RDD<dynamic>>>();
                var prevFunc = expressionData.ToFunc<Func<double, RDD<dynamic>, RDD<dynamic>>>();
                return func(t, prevFunc(t, rdd));
            }
        }

        internal override IDStreamProxy DStreamProxy
        {
            get
            {
                if (dstreamProxy == null)
                {
                    var formatter = new BinaryFormatter();
                    var stream = new MemoryStream();
                    formatter.Serialize(stream, expressionData);
                    dstreamProxy = SparkCLREnvironment.SparkCLRProxy.StreamingContextProxy.CreateCSharpDStream(prevDStreamProxy, stream.ToArray(), prevSerializedMode.ToString());
                }
                return dstreamProxy;
            }
        }
    }
}
