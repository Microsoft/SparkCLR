// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using Microsoft.Spark.CSharp.Core;
using Microsoft.Spark.CSharp.Interop.Ipc;
using Microsoft.Spark.CSharp.Proxy;

namespace Microsoft.Spark.CSharp.Streaming
{
    /// <summary>
    /// DStream representing the stream of data generated by `mapWithState` operation on a pair DStream.
    /// Additionally, it also gives access to the stream of state snapshots, that is, the state data of all keys after a batch has updated them.
    /// </summary>
    /// <typeparam name="K">Type of the key</typeparam>
    /// <typeparam name="V">Type of the value</typeparam>
    /// <typeparam name="S">Type of the state data</typeparam>
    /// <typeparam name="M">Type of the mapped data</typeparam>
    public class MapWithStateDStream<K, V, S, M> : DStream<M>
    {
        internal readonly IDStreamProxy mapWithStateDStreamProxy;
        internal DStream<KeyValuePair<K, S>> snapshotsDStream;

        internal MapWithStateDStream(IDStreamProxy deserializedMapWithStateDStreamProxy, IDStreamProxy mapWithStateDStreamProxy, StreamingContext streamingContext)
            : base(deserializedMapWithStateDStreamProxy, streamingContext)
        {
            this.snapshotsDStream = new DStream<byte[]>(mapWithStateDStreamProxy.StateSnapshots(), streamingContext, SerializedMode.None).Map(new DeserializeBytes2PairHelper<K, S>().Execute);
        }

        /// <summary>
        /// Return a pair DStream where each RDD is the snapshot of the state of all the keys.
        /// </summary>
        public DStream<KeyValuePair<K, S>> StateSnapshots()
        {
            return snapshotsDStream;
        }
    }

    [Serializable]
    internal class DeserializeBytes2PairHelper<K, S>
    {
        [NonSerialized]
        private IFormatter formatter = new BinaryFormatter();

        internal KeyValuePair<K, S> Execute(byte[] bytes)
        {
            if (formatter == null)
            {
                formatter = new BinaryFormatter();
            }

            var ms = new MemoryStream(bytes);

            K k = (K)formatter.Deserialize(new MemoryStream(SerDe.ReadBytes(ms)));
            S s = (S)formatter.Deserialize(new MemoryStream(SerDe.ReadBytes(ms)));
            return new KeyValuePair<K, S>(k, s);
        }
    }


    [Serializable]
    internal class DeserializeHelper<M>
    {
        [NonSerialized]
        private IFormatter formatter = new BinaryFormatter();

        internal M Execute(byte[] bytes)
        {
            if (formatter == null)
            {
                formatter = new BinaryFormatter();
            }

            return (M)formatter.Deserialize(new MemoryStream(bytes));
        }
    }


    [Serializable]
    internal class KeyValuePair2BytesHelper
    {
        [NonSerialized]
        private IFormatter formatter = new BinaryFormatter();

        internal byte[] Execute<K, V>(KeyValuePair<K, V> pair)
        {
            if (formatter == null)
            {
                formatter = new BinaryFormatter();
            }
            var ms = new MemoryStream();
            formatter.Serialize(ms, pair.Key);
            var keyBytes = ms.ToArray();

            var buffer = new MemoryStream();
            SerDe.WriteBytes(buffer, keyBytes);

            var ms2 = new MemoryStream();
            formatter.Serialize(ms2, pair.Value);
            var valueBytes = ms2.ToArray();

            SerDe.WriteBytes(buffer, valueBytes);

            var bytes = buffer.ToArray();
            return bytes;
        }

        internal byte[] Execute2<K, S>(KeyValuePair<K, S> pair)
        {
            if (formatter == null)
            {
                formatter = new BinaryFormatter();
            }
            var ms = new MemoryStream();
            formatter.Serialize(ms, pair.Key);
            var keyBytes = ms.ToArray();

            var buffer = new MemoryStream();
            SerDe.WriteBytes(buffer, keyBytes);

            var ms2 = new MemoryStream();
            formatter.Serialize(ms2, pair.Value);
            var valueBytes = ms2.ToArray();

            SerDe.WriteBytes(buffer, valueBytes);

            var bytes = buffer.ToArray();
            return bytes;
        }
    }

    /// <summary>
    /// Enum type for the operations done to State instance.
    /// </summary>
    internal enum MapWithStateOperation
    {
        UPDATED = 1,
        DEFINED = 2,
        REMOVED = 3
    }

    [Serializable]
    internal class MapWithStateHelper<K, V, S, M>
    {
        private readonly Func<K, V, State<S>, M> func;

        internal MapWithStateHelper(Func<K, V, State<S>, M> f)
        {
            func = f;
        }

        internal IEnumerable<dynamic> Execute(int index, IEnumerable<dynamic> input)
        {
            return input.Select(e => Process(e));
        }

        internal byte[] Process(byte[] input)
        {
            var formatter = new BinaryFormatter();
            var stream = new MemoryStream(input);

            int keyLen;
            byte[] keyBytes;
            dynamic key = ReadObject(formatter, stream, out keyLen, out keyBytes);

            dynamic value = ReadObject(formatter, stream);
            var state = ReadObject(formatter, stream);
            bool timingout = SerDe.ReadBool(stream);
            var stateWrapper = new State<S>(state, timingout);

            var ret = func(key, value, stateWrapper);

            var outputStream = new MemoryStream();
            SerDe.Write(outputStream, keyLen);
            SerDe.Write(outputStream, keyBytes);

            WriteObject(formatter, outputStream, ret);

            if (stateWrapper.removed)
            {
                SerDe.Write(outputStream, (int)MapWithStateOperation.REMOVED);
            }
            else if (stateWrapper.updated)
            {
                SerDe.Write(outputStream, (int)MapWithStateOperation.UPDATED);
                WriteObject(formatter, outputStream, stateWrapper.state);
            }
            else if (stateWrapper.defined)
            {
                SerDe.Write(outputStream, (int)MapWithStateOperation.DEFINED);
                WriteObject(formatter, outputStream, stateWrapper.state);
            }

            return outputStream.ToArray();
        }

        internal void WriteObject(IFormatter formatter, Stream stream, object obj)
        {
            var ms = new MemoryStream();
            formatter.Serialize(ms, obj);
            SerDe.WriteBytes(stream, ms.ToArray());
        }

        internal dynamic ReadObject(IFormatter formatter, Stream stream)
        {
            int len;
            byte[] bytes;
            return ReadObject(formatter, stream, out len, out bytes);
        }

        internal dynamic ReadObject(IFormatter formatter, Stream stream, out int len, out byte[] bytes)
        {
            len = SerDe.ReadInt(stream);
            if (len == 0)
            {
                bytes = new byte[0];
                return default(S);
            }

            bytes = SerDe.ReadBytes(stream, len);
            return formatter.Deserialize(new MemoryStream(bytes));
        }
    }

    /// <summary>
    /// Representing all the specifications of the DStream transformation `mapWithState` operation.
    /// </summary>
    /// <typeparam name="K">Type of the key</typeparam>
    /// <typeparam name="V">Type of the value</typeparam>
    /// <typeparam name="S">Type of the state data</typeparam>
    /// <typeparam name="M">Type of the mapped data</typeparam>
    public class StateSpec<K, V, S, M>
    {
        internal Func<K, V, State<S>, M> mappingFunction;
        internal int numPartitions = -1;
        internal TimeSpan idleDuration = TimeSpan.FromTicks(0);
        internal RDD<byte[]> initialState = null;

        /// <summary>
        /// Create a StateSpec for setting all the specifications of the `mapWithState` operation on a pair DStream.
        /// </summary>
        /// <param name="mappingFunction">The function applied on every data item to manage the associated state and generate the mapped data</param>
        public StateSpec(Func<K, V, State<S>, M> mappingFunction)
        {
            this.mappingFunction = mappingFunction;
        }

        /// <summary>
        /// Set the number of partitions by which the state RDDs generated by `mapWithState` will be partitioned.
        /// Hash partitioning will be used.
        /// </summary>
        public StateSpec<K, V, S, M> NumPartitions(int numPartitions)
        {
            this.numPartitions = numPartitions;
            return this;
        }

        /// <summary>
        /// Set the duration after which the state of an idle key will be removed. A key and its state is
        /// considered idle if it has not received any data for at least the given duration. The
        /// mapping function will be called one final time on the idle states that are going to be
        /// removed; [[org.apache.spark.streaming.State State.isTimingOut()]] set to `true` in that call.
        /// </summary>
        /// <param name="ts"></param>
        /// <returns></returns>
        public StateSpec<K, V, S, M> Timeout(TimeSpan idleDuration)
        {
            this.idleDuration = idleDuration;
            return this;
        }

        public StateSpec<K, V, S, M> InitialState(RDD<KeyValuePair<K, S>> initialState)
        {
            this.initialState = initialState.Map(new KeyValuePair2BytesHelper().Execute2);
            this.initialState.serializedMode = SerializedMode.None;
            return this;
        }
    }

    /// <summary>
    /// class for getting and updating the state in mapping function used in the `mapWithState` operation
    /// </summary>
    /// <typeparam name="S">Type of the state</typeparam>
    [Serializable]
    public class State<S>
    {
        internal S state = default(S);

        [NonSerialized]
        internal bool defined = false;
        [NonSerialized]
        internal bool timingOut = false; // FIXME: set timingOut to true for those timeouted keys
        [NonSerialized]
        internal bool updated = false;
        [NonSerialized]
        internal bool removed = false;

        internal State(S state, bool timingOut = false)
        {
            this.state = state;
            this.timingOut = timingOut;
            removed = false;
            updated = false;

            if (!timingOut)
            {
                defined = !ReferenceEquals(null, state);
            }
            else
            {
                defined = true;
            }
        }

        public bool Exists()
        {
            return defined;
        }

        public S Get()
        {
            if (defined)
            {
                return state;
            }
            throw new ArgumentException("State is not set");
        }

        public void Update(S newState)
        {
            if (removed || timingOut)
            {
                throw new ArgumentException("Cannot update the state that is timing out or has been removed.");
            }
            state = newState;
            defined = true;
            updated = true;
        }

        public void Remove()
        {
            if (removed || timingOut)
            {
                throw new ArgumentException("Cannot update the state that is timing out or has already been removed.");
            }
            defined = false;
            updated = false;
            removed = true;
        }

        public bool IsTimingOut()
        {
            return timingOut;
        }
    }
}
